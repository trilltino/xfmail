/**
 * Version Bridge
 * 
 * This module provides utilities for converting between diamond-types versions
 * (Frontier) and Braid protocol version IDs. It maintains a mapping between
 * the two systems to enable synchronization.
 */

use diamond_types::Frontier;
use uuid::Uuid;
use std::collections::HashMap;

/// Maps diamond-types Frontier to Braid version ID
/// 
/// Since diamond-types uses a Frontier (set of Local Versions) and Braid uses
/// string version IDs, we need to maintain a bidirectional mapping.
#[derive(Debug, Clone)]
pub struct VersionMap {
    /// Map from Braid version ID to diamond-types Frontier
    braid_to_frontier: HashMap<String, Frontier>,
    /// Map from diamond-types Frontier (serialized) to Braid version ID
    frontier_to_braid: HashMap<String, String>,
}

impl VersionMap {
    /// Create a new empty version map
    pub fn new() -> Self {
        Self {
            braid_to_frontier: HashMap::new(),
            frontier_to_braid: HashMap::new(),
        }
    }

    /// Convert a diamond-types Frontier to a Braid version ID
    /// 
    /// If the frontier has been seen before, returns the existing Braid version ID.
    /// Otherwise, generates a new UUID and stores the mapping.
    pub fn frontier_to_braid(&mut self, frontier: &Frontier) -> String {
        let key = Self::frontier_key(frontier);
        
        if let Some(version_id) = self.frontier_to_braid.get(&key) {
            return version_id.clone();
        }
        
        // Generate new UUID for this frontier
        let version_id = Uuid::new_v4().to_string();
        self.frontier_to_braid.insert(key.clone(), version_id.clone());
        self.braid_to_frontier.insert(version_id.clone(), frontier.clone());
        
        version_id
    }

    /// Convert a Braid version ID to a diamond-types Frontier
    /// 
    /// Returns None if the version ID is not found in the map.
    pub fn braid_to_frontier(&self, version_id: &str) -> Option<Frontier> {
        self.braid_to_frontier.get(version_id).cloned()
    }

    /// Get or create a Braid version ID for a frontier
    /// 
    /// This is similar to `frontier_to_braid` but allows specifying a custom
    /// version ID if the frontier hasn't been seen before.
    pub fn get_or_create_braid_version(&mut self, frontier: &Frontier, version_id: Option<String>) -> String {
        let key = Self::frontier_key(frontier);
        
        if let Some(existing) = self.frontier_to_braid.get(&key) {
            return existing.clone();
        }
        
        let version_id = version_id.unwrap_or_else(|| Uuid::new_v4().to_string());
        self.frontier_to_braid.insert(key.clone(), version_id.clone());
        self.braid_to_frontier.insert(version_id.clone(), frontier.clone());
        
        version_id
    }

    /// Convert multiple Braid version IDs to their parent frontiers
    /// 
    /// Returns a vector of frontiers, filtering out any that aren't found.
    pub fn braid_parents_to_frontiers(&self, parent_ids: &[String]) -> Vec<Frontier> {
        parent_ids.iter()
            .filter_map(|id| self.braid_to_frontier(id))
            .collect()
    }

    /// Convert a frontier to a serializable key for HashMap lookup
    fn frontier_key(frontier: &Frontier) -> String {
        // Serialize frontier as comma-separated LVs
        // This is deterministic and can be used as a HashMap key
        let lvs: Vec<String> = frontier.as_ref().iter().map(|lv| lv.to_string()).collect();
        lvs.join(",")
    }

    /// Check if a Braid version ID exists in the map
    pub fn has_braid_version(&self, version_id: &str) -> bool {
        self.braid_to_frontier.contains_key(version_id)
    }

    /// Get all known Braid version IDs
    pub fn all_braid_versions(&self) -> Vec<String> {
        self.braid_to_frontier.keys().cloned().collect()
    }
}

impl Default for VersionMap {
    fn default() -> Self {
        Self::new()
    }
}

/// Helper function to convert a single LV to a simple version ID
/// 
/// For simple cases where there's only one LV in the frontier,
/// we can use a simpler representation.
pub fn simple_frontier_to_string(frontier: &Frontier) -> String {
    if frontier.is_root() {
        "root".to_string()
    } else if let Some(lv) = frontier.try_get_single_entry() {
        format!("lv:{}", lv)
    } else {
        // Multiple LVs - serialize as comma-separated
        let lvs: Vec<String> = frontier.as_ref().iter().map(|lv| lv.to_string()).collect();
        format!("lv:[{}]", lvs.join(","))
    }
}

/// Helper function to parse a simple version string back to a frontier
/// 
/// This only works for the simple format generated by `simple_frontier_to_string`.
/// For full version mapping, use `VersionMap`.
pub fn parse_simple_version(version_str: &str) -> Option<Frontier> {
    if version_str == "root" {
        Some(Frontier::root())
    } else if version_str.starts_with("lv:") {
        let content = &version_str[3..];
        if content.starts_with('[') && content.ends_with(']') {
            // Multiple LVs: lv:[1,2,3]
            let content = &content[1..content.len()-1];
            let lvs: Result<Vec<usize>, _> = content.split(',').map(|s| s.trim().parse()).collect();
            if let Ok(lvs) = lvs {
                Some(Frontier::from_unsorted(&lvs))
            } else {
                None
            }
        } else {
            // Single LV: lv:42
            if let Ok(lv) = content.parse::<usize>() {
                Some(Frontier::new_1(lv))
            } else {
                None
            }
        }
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_map() {
        let mut map = VersionMap::new();
        
        let frontier1 = Frontier::new_1(10);
        let version1 = map.frontier_to_braid(&frontier1);
        
        // Same frontier should return same version ID
        let version1_again = map.frontier_to_braid(&frontier1);
        assert_eq!(version1, version1_again);
        
        // Should be able to convert back
        let frontier1_back = map.braid_to_frontier(&version1).unwrap();
        assert_eq!(frontier1.as_ref(), frontier1_back.as_ref());
    }

    #[test]
    fn test_simple_frontier_to_string() {
        let root = Frontier::root();
        assert_eq!(simple_frontier_to_string(&root), "root");
        
        let single = Frontier::new_1(42);
        assert_eq!(simple_frontier_to_string(&single), "lv:42");
        
        let multiple = Frontier::from_unsorted(&[1, 5, 10]);
        let result = simple_frontier_to_string(&multiple);
        assert!(result.starts_with("lv:["));
        assert!(result.contains("1"));
        assert!(result.contains("5"));
        assert!(result.contains("10"));
    }

    #[test]
    fn test_parse_simple_version() {
        let root = parse_simple_version("root").unwrap();
        assert!(root.is_root());
        
        let single = parse_simple_version("lv:42").unwrap();
        assert_eq!(single.as_ref(), &[42]);
        
        let multiple = parse_simple_version("lv:[1,5,10]").unwrap();
        let mut lvs: Vec<usize> = multiple.as_ref().iter().copied().collect();
        lvs.sort();
        assert_eq!(lvs, vec![1, 5, 10]);
    }
}

